{-# LANGUAGE OverloadedStrings #-}

module Main where

import AssetToText (prettyPrintAsset)
import Context
import Data.List (find, intercalate)
import Data.Maybe (fromMaybe)
import GuidNameLookup (assetLookupFile, createAssetNameLookup, loadAssetNameLookup, saveAssetNameLookup)
import Install (activate, install)
import ObjectGraph (createGameObjectTransformLookup)
import System.Directory (doesDirectoryExist)
import System.Environment (getArgs, getProgName)
import System.Exit (exitFailure)
import System.IO (Handle, hGetEncoding, hSetEncoding, mkTextEncoding, stdout)
import Uninstall (deactivate, uninstall)
import Unity.AssetModel (FileId, UnityObject)
import Unity.AssetParsing (createObjectLookup, readAssetFile)

main :: IO ()
main = do
  makeSafe stdout
  args <- getArgs
  case args of
    [flag] | any ((flag `elem`) . flags) commands -> performCommand flag
    [filePath] -> printAsset filePath
    _ -> printUsageAndFail

-- Because of an issue where we encounter an encoding error when printing some values,
-- We make the output stream safe to send unicode characters to, falling back to "???""
-- See https://stackoverflow.com/questions/27616611/run-time-exception-when-attempting-to-print-a-unicode-character
makeSafe :: Handle -> IO ()
makeSafe h = do
  Just ce <- hGetEncoding h
  ce' <- mkTextEncoding (takeWhile (/= '/') (show ce) ++ "//TRANSLIT")
  hSetEncoding h ce'

performCommand :: String -> IO ()
performCommand flag =
  function $
    fromMaybe
      (error $ "Unknown option " ++ flag)
      (find ((flag `elem`) . flags) commands)

data Command = Command
  { flags :: [String],
    function :: IO (),
    description :: String
  }

commands :: [Command]
commands =
  [ Command
      { flags = ["-r", "--rebuild-lookup"],
        function = rebuildLookup,
        description =
          "Builds a lookup of asset GUIDs to names and saves it in "
            ++ assetLookupFile
            ++ ".\nThis improves the output when converting Unity assets, by converting GUIDs to names."
      },
    Command
      { flags = ["-i", "--install"],
        function = install,
        description =
          "Installs this as a git diff driver in the current repo.\n\
          \This will:\n\
          \- add 'diff=unity' to an internal gitattributes file (.git/unity2text/attributes) for common Unity assets and\n\
          \- add this file to the setting 'core.attributesfile' in the local git config (.git/config)\n\
          \- add 'diff.unity.textconv=unity2text' in the local git config (.git/config)"
      },
    Command
      { flags = ["-u", "--uninstall"],
        function = uninstall,
        description = "Uninstalls this from the current repo, essentially reverting what --install does"
      },
    Command
      { flags = ["-a", "--activate"],
        function = activate,
        description = "Like --install, except it only changes the git config. Can be used to re-enable the diff driver after a --deactivate"
      },
    Command
      { flags = ["-d", "--deactivate"],
        function = deactivate,
        description =
          "Like --uninstall, except it only changes the git config. Useful if you want to disable the diff driver temporarily,\n\
          \but don't want to lose the lookup generated by --rebuild-lookup."
      },
    Command
      { flags = ["-h", "--help"],
        function = printUsageAndFail,
        description = "Shows this help message."
      }
  ]

printCommandDescription :: Command -> IO ()
printCommandDescription (Command {flags = fs, description = d}) = do
  putStrLn $ "    " ++ intercalate ", " fs
  mapM_ (putStrLn . ("        " ++)) (lines d)

rebuildLookup :: IO ()
rebuildLookup = do
  isInRepoRoot <- doesDirectoryExist ".git"
  if isInRepoRoot
    then
      createAssetNameLookup "." >>= saveAssetNameLookup
    else
      putStrLn "Not in repo root. Ignoring." >> exitFailure

printAsset :: FilePath -> IO ()
printAsset filePath = do
  asset <- readAssetFile filePath
  context <- makeContext asset
  prettyPrintAsset context asset

printUsageAndFail :: IO a
printUsageAndFail = do
  name <- getProgName
  putStrLn "Unity asset to text conversion"
  putStrLn "Intended as a diff driver textconv filter for Unity YAML files (*.unity, *.prefab, etc.)"
  putStrLn ""
  putStrLn $ "Usage: " ++ name ++ " <asset_file>"
  putStrLn $ "       " ++ name ++ " <option>"
  putStrLn ""
  putStrLn "Options:"
  mapM_ printCommandDescription commands
  exitFailure

makeContext :: [(FileId, UnityObject)] -> IO Context
makeContext asset = do
  assetNameLookup <- loadAssetNameLookup
  let objectLookup = createObjectLookup asset
  let gameObjectTransformLookup = createGameObjectTransformLookup asset
  return $ Context objectLookup assetNameLookup gameObjectTransformLookup